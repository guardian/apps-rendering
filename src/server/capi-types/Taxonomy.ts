/* tslint:disable */
/* eslint-disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v3.7.6
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import * as thrift from "@creditkarma/thrift-server-core";
import * as TagUsage from "./TagUsage";
import * as Tag from "./Tag";
import * as Newspaper from "./Newspaper";
import * as Reference from "./Reference";
export interface ITaxonomy {
    tags?: Array<TagUsage.ITagUsage>;
    contributors?: Array<Tag.ITag>;
    publication?: Tag.ITag;
    newspaper?: Newspaper.INewspaper;
    references?: Array<Reference.IReference>;
}
export interface ITaxonomyArgs {
    tags?: Array<TagUsage.ITagUsageArgs>;
    contributors?: Array<Tag.ITagArgs>;
    publication?: Tag.ITagArgs;
    newspaper?: Newspaper.INewspaperArgs;
    references?: Array<Reference.IReferenceArgs>;
}
export const TaxonomyCodec: thrift.IStructCodec<ITaxonomyArgs, ITaxonomy> = {
    encode(args: ITaxonomyArgs, output: thrift.TProtocol): void {
        const obj: any = {
            tags: args.tags,
            contributors: args.contributors,
            publication: args.publication,
            newspaper: args.newspaper,
            references: args.references
        };
        output.writeStructBegin("Taxonomy");
        if (obj.tags != null) {
            output.writeFieldBegin("tags", thrift.TType.LIST, 1);
            output.writeListBegin(thrift.TType.STRUCT, obj.tags.length);
            obj.tags.forEach((value_1: TagUsage.ITagUsageArgs): void => {
                TagUsage.TagUsageCodec.encode(value_1, output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (obj.contributors != null) {
            output.writeFieldBegin("contributors", thrift.TType.LIST, 2);
            output.writeListBegin(thrift.TType.STRUCT, obj.contributors.length);
            obj.contributors.forEach((value_2: Tag.ITagArgs): void => {
                Tag.TagCodec.encode(value_2, output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (obj.publication != null) {
            output.writeFieldBegin("publication", thrift.TType.STRUCT, 3);
            Tag.TagCodec.encode(obj.publication, output);
            output.writeFieldEnd();
        }
        if (obj.newspaper != null) {
            output.writeFieldBegin("newspaper", thrift.TType.STRUCT, 4);
            Newspaper.NewspaperCodec.encode(obj.newspaper, output);
            output.writeFieldEnd();
        }
        if (obj.references != null) {
            output.writeFieldBegin("references", thrift.TType.LIST, 5);
            output.writeListBegin(thrift.TType.STRUCT, obj.references.length);
            obj.references.forEach((value_3: Reference.IReferenceArgs): void => {
                Reference.ReferenceCodec.encode(value_3, output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ITaxonomy {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.LIST) {
                        const value_4: Array<TagUsage.ITagUsage> = new Array<TagUsage.ITagUsage>();
                        const metadata_1: thrift.IThriftList = input.readListBegin();
                        const size_1: number = metadata_1.size;
                        for (let i_1: number = 0; i_1 < size_1; i_1++) {
                            const value_5: TagUsage.ITagUsage = TagUsage.TagUsageCodec.decode(input);
                            value_4.push(value_5);
                        }
                        input.readListEnd();
                        _args.tags = value_4;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.TType.LIST) {
                        const value_6: Array<Tag.ITag> = new Array<Tag.ITag>();
                        const metadata_2: thrift.IThriftList = input.readListBegin();
                        const size_2: number = metadata_2.size;
                        for (let i_2: number = 0; i_2 < size_2; i_2++) {
                            const value_7: Tag.ITag = Tag.TagCodec.decode(input);
                            value_6.push(value_7);
                        }
                        input.readListEnd();
                        _args.contributors = value_6;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_8: Tag.ITag = Tag.TagCodec.decode(input);
                        _args.publication = value_8;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_9: Newspaper.INewspaper = Newspaper.NewspaperCodec.decode(input);
                        _args.newspaper = value_9;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.TType.LIST) {
                        const value_10: Array<Reference.IReference> = new Array<Reference.IReference>();
                        const metadata_3: thrift.IThriftList = input.readListBegin();
                        const size_3: number = metadata_3.size;
                        for (let i_3: number = 0; i_3 < size_3; i_3++) {
                            const value_11: Reference.IReference = Reference.ReferenceCodec.decode(input);
                            value_10.push(value_11);
                        }
                        input.readListEnd();
                        _args.references = value_10;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            tags: _args.tags,
            contributors: _args.contributors,
            publication: _args.publication,
            newspaper: _args.newspaper,
            references: _args.references
        };
    }
};
export class Taxonomy extends thrift.StructLike implements ITaxonomy {
    public tags?: Array<TagUsage.ITagUsage>;
    public contributors?: Array<Tag.ITag>;
    public publication?: Tag.ITag;
    public newspaper?: Newspaper.INewspaper;
    public references?: Array<Reference.IReference>;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ITaxonomyArgs = {}) {
        super();
        if (args.tags != null) {
            const value_12: Array<TagUsage.ITagUsage> = new Array<TagUsage.ITagUsage>();
            args.tags.forEach((value_17: TagUsage.ITagUsageArgs): void => {
                const value_18: TagUsage.ITagUsage = new TagUsage.TagUsage(value_17);
                value_12.push(value_18);
            });
            this.tags = value_12;
        }
        if (args.contributors != null) {
            const value_13: Array<Tag.ITag> = new Array<Tag.ITag>();
            args.contributors.forEach((value_19: Tag.ITagArgs): void => {
                const value_20: Tag.ITag = new Tag.Tag(value_19);
                value_13.push(value_20);
            });
            this.contributors = value_13;
        }
        if (args.publication != null) {
            const value_14: Tag.ITag = new Tag.Tag(args.publication);
            this.publication = value_14;
        }
        if (args.newspaper != null) {
            const value_15: Newspaper.INewspaper = new Newspaper.Newspaper(args.newspaper);
            this.newspaper = value_15;
        }
        if (args.references != null) {
            const value_16: Array<Reference.IReference> = new Array<Reference.IReference>();
            args.references.forEach((value_21: Reference.IReferenceArgs): void => {
                const value_22: Reference.IReference = new Reference.Reference(value_21);
                value_16.push(value_22);
            });
            this.references = value_16;
        }
    }
    public static read(input: thrift.TProtocol): Taxonomy {
        return new Taxonomy(TaxonomyCodec.decode(input));
    }
    public static write(args: ITaxonomyArgs, output: thrift.TProtocol): void {
        return TaxonomyCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return TaxonomyCodec.encode(this, output);
    }
}
